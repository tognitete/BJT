{"ast":null,"code":"var crypto = require('crypto');\n\nvar saltChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nvar saltCharsCount = saltChars.length;\n\nfunction generateSalt(len) {\n  if (typeof len != 'number' || len <= 0 || len !== parseInt(len, 10)) throw new Error('Invalid salt length');\n\n  if (crypto.randomBytes) {\n    return crypto.randomBytes(Math.ceil(len / 2)).toString('hex').substring(0, len);\n  } else {\n    for (var i = 0, salt = ''; i < len; i++) {\n      salt += saltChars.charAt(Math.floor(Math.random() * saltCharsCount));\n    }\n\n    return salt;\n  }\n}\n\nfunction generateHash(algorithm, salt, password, iterations) {\n  iterations = iterations || 1;\n\n  try {\n    var hash = password;\n\n    for (var i = 0; i < iterations; ++i) {\n      hash = crypto.createHmac(algorithm, salt).update(hash).digest('hex');\n    }\n\n    return algorithm + '$' + salt + '$' + iterations + '$' + hash;\n  } catch (e) {\n    throw new Error('Invalid message digest algorithm');\n  }\n}\n\nfunction makeBackwardCompatible(hashedPassword) {\n  var parts = hashedPassword.split('$');\n\n  if (parts.length === 3) {\n    parts.splice(2, 0, 1);\n    hashedPassword = parts.join(\"$\");\n  }\n\n  return hashedPassword;\n}\n\nmodule.exports.generate = function (password, options) {\n  if (typeof password != 'string') throw new Error('Invalid password');\n  options || (options = {});\n  options.algorithm || (options.algorithm = 'sha1');\n  options.saltLength || options.saltLength == 0 || (options.saltLength = 8);\n  options.iterations || (options.iterations = 1);\n  var salt = generateSalt(options.saltLength);\n  return generateHash(options.algorithm, salt, password, options.iterations);\n};\n\nmodule.exports.verify = function (password, hashedPassword) {\n  if (!password || !hashedPassword) return false;\n  hashedPassword = makeBackwardCompatible(hashedPassword);\n  var parts = hashedPassword.split('$');\n  if (parts.length != 4) return false;\n\n  try {\n    return generateHash(parts[0], parts[1], password, parts[2]) == hashedPassword;\n  } catch (e) {}\n\n  return false;\n};\n\nmodule.exports.isHashed = function (password) {\n  if (!password) return false;\n  return password.split('$').length == 4;\n};","map":{"version":3,"sources":["D:/polytech_nice_sophia/SI5/Programmable-web/Projet/BJT_/BJT/client-side/node_modules/password-hash/lib/password-hash.js"],"names":["crypto","require","saltChars","saltCharsCount","length","generateSalt","len","parseInt","Error","randomBytes","Math","ceil","toString","substring","i","salt","charAt","floor","random","generateHash","algorithm","password","iterations","hash","createHmac","update","digest","e","makeBackwardCompatible","hashedPassword","parts","split","splice","join","module","exports","generate","options","saltLength","verify","isHashed"],"mappings":"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","sourcesContent":["var crypto = require('crypto');\n\nvar saltChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nvar saltCharsCount = saltChars.length;\n\nfunction generateSalt(len) {\n  if (typeof len != 'number' || len <= 0 || len !== parseInt(len, 10)) throw new Error('Invalid salt length');\n  if (crypto.randomBytes) {\n    return crypto.randomBytes(Math.ceil(len / 2)).toString('hex').substring(0, len);\n  } else {\n    for (var i = 0, salt = ''; i < len; i++) {\n      salt += saltChars.charAt(Math.floor(Math.random() * saltCharsCount));\n    }\n    return salt;\n  }\n}\n\nfunction generateHash(algorithm, salt, password, iterations) {\n  iterations = iterations || 1;\n  try {\n    var hash = password;\n    for(var i=0; i<iterations; ++i) {\n      hash = crypto.createHmac(algorithm, salt).update(hash).digest('hex');\n    }\n    \n    return algorithm + '$' + salt + '$' + iterations + '$' + hash;\n  } catch (e) {\n    throw new Error('Invalid message digest algorithm');\n  }\n}\n\nfunction makeBackwardCompatible(hashedPassword) {\n  var parts = hashedPassword.split('$');\n  if(parts.length === 3) {\n    parts.splice(2,0,1);\n    hashedPassword = parts.join(\"$\");\n  }\n  \n  return hashedPassword;\n}\n\nmodule.exports.generate = function(password, options) {\n  if (typeof password != 'string') throw new Error('Invalid password');\n  options || (options = {});\n  options.algorithm || (options.algorithm = 'sha1');\n  options.saltLength || options.saltLength == 0 || (options.saltLength = 8);\n  options.iterations || (options.iterations = 1);\n  var salt = generateSalt(options.saltLength);\n  return generateHash(options.algorithm, salt, password, options.iterations);\n};\n\nmodule.exports.verify = function(password, hashedPassword) {\n  if (!password || !hashedPassword) return false;\n  hashedPassword = makeBackwardCompatible(hashedPassword);\n  var parts = hashedPassword.split('$');\n  if (parts.length != 4) return false;\n  try {\n    return generateHash(parts[0], parts[1], password, parts[2]) == hashedPassword;\n  } catch (e) {}\n  return false;\n};\n\nmodule.exports.isHashed = function(password) {\n  if (!password) return false;\n  return password.split('$').length == 4;\n}\n"]},"metadata":{},"sourceType":"script"}